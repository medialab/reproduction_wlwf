library(tidyverse)
library(tidyr)
library(stats)
library(vars)
library(boot)
library(rio)
library(stringr)
library(data.table)
library(urca)
library(stats)
library(dplyr)

 #Serial autocorrelation test which is robust to heteroskedasticity
auto.portmanteau.test <- function(x, q=2.4, correction = c("none", "bonferroni", "holm"), d=NULL,  alpha = 0.05){ #default q Penalty term similar as the article
    if (!(is(x, "varest"))) {
        stop("\nPlease provide an object of class 'varest', generated by 'var()'")
    }
    obs <- x$obs
    if (is.null(d)){
      d <- round(obs/12, 0)
    }
    resids <- resid(x)
    endog <- names(x$varresult)
    result <- data.frame(matrix(NA, nrow=0, ncol=3))
    colnames(result) <- c("Variable", "AQ_Statistic", "pvalue")
    for (var in endog){ #Compute test for each variables of the VAR process
        resid <- resids[, var]
        mean_resid <- mean(resid)
        list_gamma <- c()
        list_theta<- c()
        list_forpi <- c()
        for (j in 1:d){ #Loop to calculate gamma_j and theta_j for each j in 1:d
            sum_j <-0
            sum_j2 <-0
            for (t in (j+1):obs){
                sum_j <- (resid[t] - mean_resid) * (resid[t-j] - mean_resid) + sum_j
                sum_j2 <- (resid[t] - mean_resid)^2 * (resid[t-j] - mean_resid)^2 + sum_j2
            }
            gamma_j <- (1/(obs-j) * sum_j)^2
            theta_j <- 1/(obs-j) * sum_j2
            forpi_j <- sqrt(abs(gamma_j/theta_j)) * sqrt(obs) 

            list_gamma <- c(list_gamma, gamma_j)
            list_theta <- c(list_theta, theta_j)
            list_forpi <- c(list_forpi, forpi_j)
        }
        #Calculate Lp to define tilde(p)
        list_p <- c()
        for (h in 1:d){
          if(max(list_forpi) > sqrt(q*log(obs))){
              penalty <- 2*h
          } else {
              penalty <- h*log(obs)
          }
          sum_H <- 0 
          for (j in 1:h){
             sum_H <- sum_H + list_gamma[j]/list_theta[j]
          }
          Lh <- obs*sum_H - penalty
          list_p <- c(list_p, Lh) 
        }
        max_val <- max(list_p)
        indices_max <- which(list_p == max_val)
        p <- min(indices_max) 
        #Calculate AQ stat and p-value
        sum_forQ <- 0 
        for (j in 1:p){
            sum_forQ <- sum_forQ + list_gamma[j]/list_theta[j]
        }
        test_stat <- obs*sum_forQ    
        p_value <- 1 - pchisq(test_stat, df=1) #because AQ --> Chi2(1) so we can calculate p-value like this. 
        if (correction == "bonferroni"){
          p_value <- length(endog) * p_value 
        } 
        new_row <- data.frame(
            Variable = var,
            AQ_Statistic = round(test_stat, 5),
            pvalue = p_value 
        )
        result <- rbind(result, new_row)
    }
  #Holm procedure 
  if (correction =="holm") {
    p_values_sorted <- sort(result$pvalue)
    idx_order <- order(result$pvalue)
    var_sorted <- result$Variable[idx_order]
    K <- length(endog)
    rank_H <- 1
    list_padj <- c()
    for (pval in p_values_sorted){
      padj <- pval*K
      if (padj > alpha){
        accepted <- var_sorted[rank_H:length(endog)]
        rejected <- setdiff(var_sorted, accepted)
        H0 <- ifelse(var_sorted %in% accepted, "accepted", "rejected")
        result2 <- data.frame(
          Variable = var_sorted,
          pvalue_beforeadj = p_values_sorted,
          H0 = H0
        )
          break
        } else {
            if (rank_H == length(endog)){
              result2 <- data.frame(
              Variable = result$Variable,
              pvalue_beforeadj = result$pvalue,
              H0 = "rejected"
              )
            }
          }
        K <- K- 1
        rank_H <- rank_H + 1
      }
    result <- result2
  }
  return(result)
}

#Edited functions from vars package to compute GIRF

Theta <- function(x, nstep = NULL, ...){ #Inspired by vars::Psi function but to calculate GIRF 
  if (!is(x, "varest")) {
      stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  nstep <- abs(as.integer(nstep))
  Phi <- vars::Phi(x, nstep = nstep)
  Thita_mat <- array(0, dim = dim(Phi))
  endog <- names(x$varresult)
  K <- length(endog)
  Sigma <- summary(x)$covres #Covariance Matrix
  dim3 <- dim(Phi)[3]
  for (step in 1:dim3){
    Phi_i <- Phi[,,step]
    for (k in 1:K){
      e_j <- rep(0, K); e_j[k] <- 1
      new_col <- Phi_i %*% Sigma %*% e_j / sqrt(Sigma[k,k]) 
      Thita_mat[, k, step] <- new_col 
    }
  }
  return(Thita_mat)
}

.irf.edit <- function(x, impulse = NULL, response = NULL, n.ahead = NULL, irf_type = c("none", "ortho", "generalized"), cumulative = FALSE, y.names = NULL){ #Adapt to irf_type and allow to select Theta matrix if geenralzied option is selected 
    if (is(x, "varest") || is(x, "vec2var")) {
        if (irf_type == "ortho") {
            irf <- vars::Psi(x, nstep = n.ahead)
        }
        else if (irf_type == "generalized") {
            irf <- Theta(x, nstep = n.ahead)
        } else {
            irf <- Phi(x, nstep = n.ahead)
        }
    }
    else if (is(x, "svarest") || is(x, "svecest")) {
        irf <- Phi(x, nstep = n.ahead)
    }
    dimnames(irf) <- list(y.names, y.names, NULL)
    idx <- length(impulse)
    irs <- list()
    for (i in 1:idx) {
        irs[[i]] <- matrix(t(irf[response, impulse[i], 1:(n.ahead + 
            1)]), nrow = n.ahead + 1)
        colnames(irs[[i]]) <- response
        if (cumulative) {
            if (length(response) > 1) 
                irs[[i]] <- apply(irs[[i]], 2, cumsum)
            if (length(response) == 1) {
                tmp <- matrix(cumsum(irs[[i]]))
                colnames(tmp) <- response
                irs[[i]] <- tmp
            }
        }
    }
    names(irs) <- impulse
    result <- irs
    return(result)
}

.boot.edit <- function(x = x, n.ahead = NULL, runs = NULL, 
            irf_type = c("none", "ortho", "generalized"), cumulative = FALSE, impulse = NULL, 
            response = NULL, ci = 0.95, seed = NULL, y.names = NULL){ #Adaptation of .boot function to .irf.edit
  if (!(is.null(seed))) 
        set.seed(abs(as.integer(seed)))
    if (is(x, "varest")) {
        VAR <- eval.parent(x)
    }
    else if (is(x, "svarest")) {
        VAR <- eval.parent(x$var)
    }
    else {
        stop("Bootstrap not implemented for this class.\n")
    }
    p <- VAR$p
    K <- VAR$K
    obs <- VAR$obs
    total <- VAR$totobs
    type <- VAR$type
    B <- Bcoef(VAR)
    BOOT <- vector("list", runs)
    ysampled <- matrix(0, nrow = total, ncol = K)
    colnames(ysampled) <- colnames(VAR$y)
    Zdet <- NULL
    if (ncol(VAR$datamat) > (K * (p + 1))) {
        Zdet <- as.matrix(VAR$datamat[, (K * (p + 1) + 1):ncol(VAR$datamat)])
    }
    resorig <- scale(resid(VAR), scale = FALSE)
    B <- Bcoef(VAR)
    for (i in 1:runs) {
        booted <- sample(c(1:obs), replace = TRUE)
        resid <- resorig[booted, ]
        lasty <- c(t(VAR$y[p:1, ]))
        ysampled[c(1:p), ] <- VAR$y[c(1:p), ]
        for (j in 1:obs) {
            lasty <- lasty[1:(K * p)]
            Z <- c(lasty, Zdet[j, ])
            ysampled[j + p, ] <- B %*% Z + resid[j, ]
            lasty <- c(ysampled[j + p, ], lasty)
        }
        varboot <- update(VAR, y = ysampled)
        if (is(x, "svarest")) {
            varboot <- update(x, x = varboot)
        }
        BOOT[[i]] <- .irf.edit(x = varboot, n.ahead = n.ahead,  irf_type = irf_type, 
            cumulative = cumulative, impulse = impulse, response = response, 
            y.names = y.names) #Just edit here to boot with geenralzied option
    }
    lower <- ci/2
    upper <- 1 - ci/2
    mat.l <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
    mat.u <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
    Lower <- list()
    Upper <- list()
    idx1 <- length(impulse)
    idx2 <- length(response)
    idx3 <- n.ahead + 1
    temp <- rep(NA, runs)
    for (j in 1:idx1) {
        for (m in 1:idx2) {
            for (l in 1:idx3) {
                for (i in 1:runs) {
                  if (idx2 > 1) {
                    temp[i] <- BOOT[[i]][[j]][l, m]
                  }
                  else {
                    temp[i] <- matrix(BOOT[[i]][[j]])[l, m]
                  }
                }
                mat.l[l, m] <- quantile(temp, lower, na.rm = TRUE)
                mat.u[l, m] <- quantile(temp, upper, na.rm = TRUE)
            }
        }
        colnames(mat.l) <- response
        colnames(mat.u) <- response
        Lower[[j]] <- mat.l
        Upper[[j]] <- mat.u
    }
    names(Lower) <- impulse
    names(Upper) <- impulse
    result <- list(Lower = Lower, Upper = Upper)
    return(result)
}

irf.varest.edit <- function (x,impulse = NULL, response = NULL, n.ahead = 10, irf_type = c("none", "ortho", "generalized"), cumulative = FALSE, boot = TRUE, ci = 0.95, runs = 100, seed = NULL, ...) #Ortho argument was replaced by irf_type argument : OIRF, GIRF or no transformation (none). 
{
    if (!is(x, "varest")) {
        stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
    }

    y.names <- colnames(x$y)
    if (is.null(impulse)) {
        impulse <- y.names
    }
    else {
        impulse <- as.vector(as.character(impulse))
        if (any(!(impulse %in% y.names))) {
            stop("\nPlease provide variables names in impulse\nthat are in the set of endogenous variables.\n")
        }
        impulse <- subset(y.names, subset = y.names %in% impulse)
    }
    if (is.null(response)) {
        response <- y.names
    }
    else {
        response <- as.vector(as.character(response))
        if (any(!(response %in% y.names))) {
            stop("\nPlease provide variables names in response\nthat are in the set of endogenous variables.\n")
        }
        response <- subset(y.names, subset = y.names %in% response)
    }
    irs <- .irf.edit(x = x, impulse = impulse, response = response, 
        y.names = y.names, n.ahead = n.ahead, irf_type=irf_type, 
        cumulative = cumulative)
    Lower <- NULL
    Upper <- NULL
    if (boot) {
        ci <- as.numeric(ci)
        if ((ci <= 0) | (ci >= 1)) {
            stop("\nPlease provide a number between 0 and 1 for the confidence interval.\n")
        }
        ci <- 1 - ci
        BOOT <- .boot.edit(x = x, n.ahead = n.ahead, runs = runs, 
            irf_type = irf_type, cumulative = cumulative, impulse = impulse, 
            response = response, ci = ci, seed = seed, y.names = y.names)
        Lower <- BOOT$Lower
        Upper <- BOOT$Upper
    }
    result <- list(irf = irs, Lower = Lower, Upper = Upper, response = response, 
        impulse = impulse,  irf_type = irf_type, cumulative = cumulative, 
        runs = runs, ci = ci, boot = boot, model = class(x))
    class(result) <- "varirf"
    return(result)
}

#Format ACF table
transfo_acf <- function(data){
    df <- as.data.frame(data)
    df$value <- sapply(strsplit(as.character(df$Freq), ":"), function(x) x[2])
    if (any(grepl("NA's\\s*", df$Freq, ignore.case = TRUE))) {
    print("NA detected")
    nrow_exp <- 7
    rows_exp <- c("Min", "Q1", "Median", "Mean", "Q3", "Max", "Missing")
    } else {
    print("NA Undetected")
    nrow_exp <- 6
    rows_exp <- c("Min", "Q1", "Median", "Mean", "Q3", "Max")
    }
    dfexp <- as.data.frame(matrix(NA, nrow=nrow_exp, ncol=length(variables)*2))
    colnames(dfexp) <- c(variables, paste0(variables, "_diff"))
    rownames(dfexp) <- rows_exp
    k <- 0
    for (i in 1:ncol(dfexp)){
    print(i)
    for (j in 1:nrow_exp){
        dfexp[j,i] <- str_trim(df[j + k*nrow_exp, "value"])
    }
    k <- k+1
    }
    return(dfexp)
}

#Plot Tools 

#Create ACF and PACF plots
plot_PACFS <- function(data, type){
    if (!(type %in% c("ACF", "PACF"))){
    stop("Choose ACF or PACF type for schem")
    }
    path_ACF <- paste0("data_prod/var/issue-level/", type, "_plot.png")
    png(file=path_ACF, width = 1800, height = 1200)
    db_plot <- as.data.frame(t(data))
    db_plot <- db_plot[, variables]
    db_plot$stationarity <- ifelse(rownames(db_plot) %in% as.character(stationary_topics), TRUE, FALSE)
    db_plot$topic <- rownames(db_plot)
    db_plot_long <-  db_plot %>% gather(key="groups", value = "value", variables)
    max_y <- max(db_plot_long$value)
    p <- ggplot(data = db_plot_long, aes(x = as.integer(topic), y = value, color=groups, shape = as.factor(stationarity), xmin = 0, xmax = 101, ymin=0, ymax= max_y + 1)) +
        geom_jitter(width = 0.3, size = 5) +  
        scale_shape_manual(values = c("TRUE" = 18, "FALSE" = 16), labels = c("TRUE" = "Stationnaire", "FALSE" = "Mixte"), name = "Stationnarité") +
        scale_color_manual(values = c(
                                "lr" = "blue",
                                "majority" = "orange",
                                "nupes" = "red",
                                "rn" = "purple",
                                "media" = "black", 
                                "majority_supp" = "darkorange", 
                                "lr_supp" = "darkblue", 
                                "nupes_supp" = "darkred", 
                                "rn_supp" = "purple4", 
                                "attentive" = "forestgreen", 
                                "general" = "lightgrey"
                                )) +
        labs(
        title = paste(type, "day where value was < 0.1 for model", args$topic_model),
        x = "Topics",
        y = "Number of days")
    print(p)
    dev.off()
}

#panelvar
panel_lag <- function(x, k) {
  # first column contains time
  # other columns the data
  # k number of lags
  res <-
    rbind(matrix(NA, 1, ncol(x) - 1), as.matrix(x[1:(nrow(x) - 1), -1]), deparse.level = 1)
  colnames(res) <- colnames(x)[-1]
  
  if (k > 1) {
    for (l in 2:k) {
      res <-
        cbind(res, rbind(matrix(NA, l, ncol(x) - 1), as.matrix(x[1:(nrow(x) - l), -1])))
    }
  }
  
  #if (k > 1){
  res[rep(is.na(x[, -1]), k)] <- NA # multiple lags
  #}
  
  # only necessary if single variable with multiple lags
  if(ncol(x) == 2) colnames(res) <- rep(colnames(res)[1], ncol(res))
  
  colnames(res) <- paste0("lag", rep(1:k, each = ncol(x)-1), "_", colnames(res))
  rownames(res) <- NULL
  res
}

demean <- function(x) {
  x - mean(x, na.rm = TRUE)
}

panel_demean <- function(x, transformation) {
  res <- apply(x[, -(1:2)], 2, demean)
  colnames(res) <- paste("demeaned", colnames(res), sep = "_")
  rownames(res) <- NULL
  res
}

WITHIN_TRANSFO <- function(dependent_vars, lags, data, panel_identifier){
  data <- droplevels(data)
  required_vars <- c(dependent_vars)
  if (is.numeric(panel_identifier)) {
    Set_Vars <-
      data[, c(colnames(data)[panel_identifier], required_vars)]
  } else {
    Set_Vars <-
      data[, c(panel_identifier, required_vars)]
  }
  
  nof_dependent_vars <- length(dependent_vars)
  nof_exog_vars <- 0
  categories <- sort(unique(Set_Vars[, 1]))
  periods <- sort(unique(Set_Vars[, 2]))
  nof_categories <- length(categories)
  nof_periods <- length(periods)
  lags <- abs(as.integer(lags))
  
  name_category <- names(Set_Vars)[1]
  name_period <- names(Set_Vars)[2]
  names(Set_Vars)[1:2] <- c("category", "period")
  
  Set_Vars <- Set_Vars[order(Set_Vars$category, Set_Vars$period,decreasing = FALSE),]
  Set_Vars$category <- factor(Set_Vars$category)
  Set_Vars$period <- factor(Set_Vars$period)
  # Add lags of dependent_vars
  Set_Vars <- cbind(Set_Vars,
                    do.call(
                      rbind,
                      mapply(
                        function(i)
                          panel_lag(Set_Vars[Set_Vars$category == categories[i], c("period", dependent_vars)], lags),
                        1:length(categories),
                        SIMPLIFY = FALSE
                      )
                    )) 
  #Demeaning
  Set_Vars <- cbind(Set_Vars,
                    do.call(
                      rbind,
                      mapply(
                        function(i)
                          panel_demean(Set_Vars[Set_Vars$category == categories[i],], demean),
                        1:length(categories),
                        SIMPLIFY = FALSE
                      )
                    )) 
  Set_Vars <- na.exclude(Set_Vars)
  return(Set_Vars)
}

PVARselect <- function(data, dependent_vars, lag.max, panel_identifier){ 
  lag <- abs(as.integer(lag.max + 1))
  K <- length(dependent_vars)
  max_NotUsed <- K*(lag) + 2
  data <- as.data.frame(data)
  demeaned_data <- WITHIN_TRANSFO(variables, lag.max, data, panel_identifier)
  cols_to_exclude <- names(demeaned_data)[1:max_NotUsed]
  demeaned_data <- demeaned_data[, -(1:max_NotUsed)]
  yendog <- as.matrix(demeaned_data[, 1:K])
  ylagged <- as.matrix(demeaned_data[, -(1:K)])
  sample <- nrow(ylagged)
  rhs <- NULL
  detint <- 0
  idx <- seq(K, K * lag.max, K)
  criteria <- matrix(NA, nrow = 4, ncol = lag.max)
  rownames(criteria) <- c("AIC(n)", "HQ(n)", "SC(n)", "FPE(n)")
  colnames(criteria) <- paste(seq(1:lag.max))
  for (i in 1:lag.max) {
    ys.lagged <- cbind(ylagged[, c(1:idx[i])], rhs)
    sampletot <- nrow(data)
    nstar <- ncol(ys.lagged)
    resids <- lm.fit(x = ys.lagged, y = yendog)$residuals
    sigma.det <- det(crossprod(resids)/sample)
    criteria[1, i] <- log(sigma.det) + (2/sample) * (i * 
                                                       K^2 + K * detint)
    criteria[2, i] <- log(sigma.det) + (2 * log(log(sample))/sample) * 
      (i * K^2 + K * detint)
    criteria[3, i] <- log(sigma.det) + (log(sample)/sample) * 
      (i * K^2 + K * detint)
    criteria[4, i] <- ((sample + nstar)/(sample - nstar))^K * 
      sigma.det
  }
  order <- apply(criteria, 1, which.min)
  return(list(selection = order, criteria = criteria))
}

PVAR_PAC_TEST <- function(model, q=2.4){
    category_indices <- levels(model$Set_Vars$category)
    num_periods <- length(levels(PVAR_model$Set_Vars$period))
    lags <- model$lags
    obs <- num_periods-lags
    i <- 1 
    endog <- model$dependent_vars
    ncol_table <- length(endog) + 1
    table_test <- data.frame(matrix(NA, nrow=0, ncol=ncol_table))
    colnames(table_test) <- c("Topic", endog)
    dem_endog <- colnames(model$residuals)
    for (idx in category_indices){
        start <- (i-1)*obs + 1
        end <- i*obs
        resids <- model$residuals[start:end,]
        pval_list <- c()
        for (var in dem_endog){
            resid <- resids[, var]
            mean_resid <- mean(resid)
            list_gamma <- c()
            list_theta<- c()
            list_forpi <- c()
            for (j in 1:(obs-1)){
                sum_j <-0
                sum_j2 <-0
                for (t in (j+1):obs){
                    sum_j <- (resid[t] - mean_resid) * (resid[t-j] - mean_resid) + sum_j
                    sum_j2 <- (resid[t] - mean_resid)^2 * (resid[t-j] - mean_resid)^2 + sum_j2
                }
                gamma_j <- (1/(obs-j) * sum_j)^2
                theta_j <- 1/(obs-j) * sum_j2

                list_gamma <- c(list_gamma, gamma_j)
                list_theta <- c(list_theta, theta_j)
                list_forpi <- abs(gamma_j/theta_j) *sqrt(obs)
            }
            sum_forQ <- 0
            list_p <- c()
            list_pi <- c()
            for (h in 1:(obs-1)){
                if(max(list_forpi) > sqrt(q*log(obs))){
                    pi_h <- 2*h
                } else {
                    pi_h <- h*log(obs)
                }
                list_pi <- c(list_pi, pi_h)
            }
            for (p in 1:(obs-1)){
                sum_forQ <- 0
                for (j in 1:p){
                    sum_forQ <- sum_forQ + list_gamma[j]/list_theta[j]
                }
                test_stat <- obs*sum_forQ
                Lp <- test_stat - list_pi[p]
                for (h in 1:(obs-1)){
                    Lh <- test_stat - list_pi[h]
                    if (Lp>=Lh){
                        list_p <- c(list_p, p)
                    }
                }
            }
            p <- min(list_p)
            sum_forQ <- 0
            for (j in 1:p){
                sum_forQ <- sum_forQ + list_gamma[j]/list_theta[j]
            }
            test_stat <- obs*sum_forQ
            p_value <- 1 - pchisq(test_stat, df=1)
            p_value <- round(p_value, 5)
            pval_list <- c(pval_list, p_value)
        }
        new_row <- c(category_indices[i], pval_list)
        table_test <- rbind(table_test, new_row)
        i <- i+1
    }
    return(table_test)
}

jb_multi <- function (x, obs, K, obj.name) {
    P <- chol(crossprod(x)/obs)
    resids.std <- x %*% solve(P)
    b1 <- apply(resids.std, 2, function(x) sum(x^3)/obs)
    b2 <- apply(resids.std, 2, function(x) sum(x^4)/obs)
    s3 <- obs * t(b1) %*% b1/6
    s4 <- obs * t(b2 - rep(3, K)) %*% (b2 - rep(3, K))/24
    STATISTIC <- s3 + s4
    names(STATISTIC) <- "Chi-squared"
    PARAMETER <- 2 * K
    names(PARAMETER) <- "df"
    PVAL <- 1 - pchisq(STATISTIC, df = PARAMETER)
    METHOD <- "JB-Test (multivariate)"
    result1 <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = paste("Residuals of VAR object", 
            obj.name))
    class(result1) <- "htest"
    STATISTIC <- s3
    names(STATISTIC) <- "Chi-squared"
    PARAMETER <- K
    names(PARAMETER) <- "df"
    PVAL <- 1 - pchisq(STATISTIC, df = PARAMETER)
    METHOD <- "Skewness only (multivariate)"
    result2 <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = paste("Residuals of VAR object", 
            obj.name))
    class(result2) <- "htest"
    STATISTIC <- s4
    names(STATISTIC) <- "Chi-squared"
    PARAMETER <- K
    names(PARAMETER) <- "df"
    PVAL <- 1 - pchisq(STATISTIC, df = PARAMETER)
    METHOD <- "Kurtosis only (multivariate)"
    result3 <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = paste("Residuals of VAR object", 
            obj.name))
    class(result3) <- "htest"
    result <- list(JB = result1, Skewness = result2, Kurtosis = result3)
    return(result)
}

PVAR_normality.test <-function(model){
    obj.name <- deparse(substitute(x))
    K <- ncol(model$residuals)
    obs <- nrow(model$residuals)
    resid <-  model$residuals
    resids <- scale(resid, scale = FALSE)
    jbm.resids <- jb_multi(resids, obs = obs, K = K, obj.name = obj.name)
    result <- list(resid = resid, jb.mul = jbm.resids)
    return(result)
}