library(dplyr)
library(tidyverse)
library(tidyr)
library(stats)
library(vars)
library(boot)
library(rio)
library(stringr)
library(data.table)
library(urca)

 #Serial autocorrelation test which is robust to heteroskedasticity
serial.test.H <- function(x, lags.pt, lags.bg, q=2.4, type=c("PT.asymptotic", "PT.adjusted", "PT.EL", "BG", "ES")){ #default q Penalty term similar as the article
if (!(is(x, "varest") || is(x, "vec2var"))) {
    stop("\nPlease provide an object of class 'varest', generated by 'var()', or an object of class 'vec2var' generated by 'vec2var()'.\n")
}
obj.name <- deparse(substitute(x))
type <- match.arg(type)
K <- x$K
obs <- x$obs
resids <- resid(x)
if ((type == "PT.asymptotic") || (type == "PT.adjusted")) {
    lags.pt <- abs(as.integer(lags.pt))
    ptm <- .pt.multi(x, K = K, obs = obs, lags.pt = lags.pt, 
        obj.name = obj.name, resids = resids)
    ifelse(type == "PT.asymptotic", test <- ptm[[1]], test <- ptm[[2]])
} else if (type=="PT.EL") {
    mean_resid <- mean(resids)
    list_gamma <- c()
    list_theta<- c()
    list_forpi <- c()
    for (j in 1:(obs-1)){
        sum_j <-0
        sum_j2 <-0
        for (t in (j+1):obs){
            sum_j <- (resids[t] - mean_resid) * (resids[t-j] - mean_resid) + sum_j
            sum_j2 <- (resids[t] - mean_resid)^2 * (resids[t-j] - mean_resid)^2 + sum_j2
        }
        gamma_j <- (1/(obs-j) * sum_j)^2
        theta_j <- 1/(obs-j) * sum_j2

        list_gamma <- c(list_gamma, gamma_j)
        list_theta <- c(list_theta, theta_j)
        list_forpi <- abs(gamma_j/theta_j) *sqrt(obs)
    }
    sum_forQ <- 0
    list_p <- c()
    list_pi <- c()
    for (h in 1:(obs-1)){
        if(max(list_forpi) > sqrt(q*log(obs))){
            pi_h <- 2*h
        } else {
            pi_h <- h*log(obs)
        }
        list_pi <- c(list_pi, pi_h)
    }
    for (p in 1:(obs-1)){
        sum_forQ <- 0
        for (j in 1:p){
            sum_forQ <- sum_forQ + list_gamma[j]/list_theta[j]
        }
        test_stat <- obs*sum_forQ
        Lp <- test_stat - list_pi[p]
        for (h in 1:(obs-1)){
            Lh <- test_stat - list_pi[h]
            if (Lp>=Lh){
                list_p <- c(list_p, p)
            }
        }
    }
    p <- min(list_p)
    sum_forQ <- 0
    for (j in 1:p){
        sum_forQ <- sum_forQ + list_gamma[j]/list_theta[j]
    }
    test_stat <- obs*sum_forQ
    p_value <- 1 - pchisq(test_stat, df=1)
    test <- list(statistic_AQ = test_stat, p.value = p_value)
} else {
    lags.bg <- abs(as.integer(lags.bg))
    bgm <- .bgserial(x, K = K, obs = obs, lags.bg = lags.bg, 
        obj.name = obj.name, resids = resids)
    ifelse(type == "BG", test <- bgm[[1]], test <- bgm[[2]])
}
result <- list(resid = resids, serial = test)
class(result) <- "varcheck"
return(result)
}

#Format ACF table
transfo_acf <- function(data){
    df <- as.data.frame(data)
    df$value <- sapply(strsplit(as.character(df$Freq), ":"), function(x) x[2])
    if (any(grepl("NA's\\s*", df$Freq, ignore.case = TRUE))) {
    print("NA detected")
    nrow_exp <- 7
    rows_exp <- c("Min", "Q1", "Median", "Mean", "Q3", "Max", "Missing")
    } else {
    print("NA Undetected")
    nrow_exp <- 6
    rows_exp <- c("Min", "Q1", "Median", "Mean", "Q3", "Max")
    }
    dfexp <- as.data.frame(matrix(NA, nrow=nrow_exp, ncol=length(variables)*2))
    colnames(dfexp) <- c(variables, paste0(variables, "_diff"))
    rownames(dfexp) <- rows_exp
    k <- 0
    for (i in 1:ncol(dfexp)){
    print(i)
    for (j in 1:nrow_exp){
        dfexp[j,i] <- str_trim(df[j + k*nrow_exp, "value"])
    }
    k <- k+1
    }
    return(dfexp)
}

#Plot Tools 

#Create ACF and PACF plots
plot_PACFS <- function(data, type){
    if (!(type %in% c("ACF", "PACF"))){
    stop("Choose ACF or PACF type for schem")
    }
    path_ACF <- paste0("data_prod/var/bertopic/issue-level/", type, "_plot.png")
    png(file=path_ACF, width = 1800, height = 1200)
    db_plot <- as.data.frame(t(data))
    db_plot <- db_plot[, variables]
    db_plot$stationarity <- ifelse(rownames(db_plot) %in% as.character(stationary_topics), TRUE, FALSE)
    db_plot$topic <- rownames(db_plot)
    db_plot_long <-  db_plot %>% gather(key="groups", value = "value", variables)
    max_y <- max(db_plot_long$value)
    p <- ggplot(data = db_plot_long, aes(x = as.integer(topic), y = value, color=groups, shape = as.factor(stationarity), xmin = 0, xmax = 101, ymin=0, ymax= max_y + 1)) +
        geom_jitter(width = 0.3, size = 5) +  
        scale_shape_manual(values = c("TRUE" = 18, "FALSE" = 16), labels = c("TRUE" = "Stationnaire", "FALSE" = "Mixte"), name = "StationnaritÃ©") +
        scale_color_manual(values = c(
                                "lr" = "blue",
                                "majority" = "orange",
                                "nupes" = "red",
                                "rn" = "purple",
                                "media" = "black", 
                                "majority_supp" = "darkorange", 
                                "lr_supp" = "darkblue", 
                                "nupes_supp" = "darkred", 
                                "rn_supp" = "purple4", 
                                "attentive" = "forestgreen", 
                                "general" = "lightgrey"
                                )) +
        labs(
        title = paste(type, "day where value was < 0.1 for model", args$topic_model),
        x = "Topics",
        y = "Number of days")
    print(p)
    dev.off()
}
