library(tidyverse)
library(tidyr)
library(stats)
library(vars)
library(boot)
library(rio)
library(stringr)
library(data.table)
library(urca)
library(stats)
library(dplyr)

 #Serial autocorrelation test which is robust to heteroskedasticity
auto.portmanteau.test <- function(x, q=2.4, correction = c("none", "bonferroni", "holm"), d=NULL,  alpha = 0.05){ #default q Penalty term similar as the article
    if (!(is(x, "varest"))) {
        stop("\nPlease provide an object of class 'varest', generated by 'var()'")
    }
    obs <- x$obs
    if (is.null(d)){
      d <- round(obs/12, 0)
    }
    resids <- resid(x)
    endog <- names(x$varresult)
    result <- data.frame(matrix(NA, nrow=0, ncol=3))
    colnames(result) <- c("Variable", "AQ_Statistic", "pvalue") # Peut être à edit 
    for (var in endog){ #Compute test for each variables of the VAR process
        resid <- resids[, var]
        mean_resid <- mean(resid)
        list_gamma <- c()
        list_theta<- c()
        list_forpi <- c()
        for (j in 1:d){ #Loop to calculate gamma_j and theta_j for each j in 1:d
            sum_j <-0
            sum_j2 <-0
            for (t in (j+1):obs){
                sum_j <- (resid[t] - mean_resid) * (resid[t-j] - mean_resid) + sum_j
                sum_j2 <- (resid[t] - mean_resid)^2 * (resid[t-j] - mean_resid)^2 + sum_j2
            }
            gamma_j <- (1/(obs-j) * sum_j)^2
            theta_j <- 1/(obs-j) * sum_j2
            forpi_j <- sqrt(abs(gamma_j/theta_j)) * sqrt(obs) 

            list_gamma <- c(list_gamma, gamma_j)
            list_theta <- c(list_theta, theta_j)
            list_forpi <- c(list_forpi, forpi_j)
        }
        #Calculate Lp to define tilde(p)
        list_p <- c()
        for (h in 1:d){
          if(max(list_forpi) > sqrt(q*log(obs))){
              penalty <- 2*h
          } else {
              penalty <- h*log(obs)
          }
          sum_H <- 0 
          for (j in 1:h){
             sum_H <- sum_H + list_gamma[j]/list_theta[j]
          }
          Lh <- obs*sum_H - penalty
          list_p <- c(list_p, Lh) 
        }
        max_val <- max(list_p)
        indices_max <- which(list_p == max_val)
        p <- min(indices_max) 
        #Calculate AQ stat and p-value
        sum_forQ <- 0 
        for (j in 1:p){
            sum_forQ <- sum_forQ + list_gamma[j]/list_theta[j]
        }
        test_stat <- obs*sum_forQ    
        p_value <- 1 - pchisq(test_stat, df=1) #because AQ --> Chi2(1) so we can calculate p-value like this. 
        if (correction == "bonferroni"){
          p_value <- length(endog) * p_value 
        } 
        new_row <- data.frame(
            Variable = var,
            AQ_Statistic = round(test_stat, 5),
            pvalue = p_value 
        )
        result <- rbind(result, new_row)
    }
  #Holm procedure 
  if (correction =="holm") {
    p_values_sorted <- sort(result$pvalue)
    idx_order <- order(result$pvalue)
    var_sorted <- result$Variable[idx_order]
    K <- length(endog)
    rank_H <- 1
    list_padj <- c()
    for (pval in p_values_sorted){
      padj <- pval*K
      if (padj > alpha){
        accepted <- var_sorted[rank_H:length(endog)]
        rejected <- setdiff(var_sorted, accepted)
        H0 <- ifelse(var_sorted %in% accepted, "accepted", "rejected")
        result2 <- data.frame(
          Variable = var_sorted,
          pvalue_beforeadj = p_values_sorted,
          H0 = H0
        )
          break
        } else {
            if (rank_H == length(endog)){
              result2 <- data.frame(
              Variable = result$Variable,
              pvalue_beforeadj = result$pvalue,
              H0 = "rejected"
              )
            }
          }
        K <- K- 1
        rank_H <- rank_H + 1
      }
    result <- result2
  }
  return(result)
}

#Edited functions from vars package to compute GIRF

Theta <- function(x, nstep = NULL, ...){ #Inspired by vars::Psi function but to calculate GIRF 
  if (!is(x, "varest")) {
      stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  nstep <- abs(as.integer(nstep))
  Phi <- vars::Phi(x, nstep = nstep)
  Thita_mat <- array(0, dim = dim(Phi))
  endog <- names(x$varresult)
  K <- length(endog)
  Sigma <- summary(x)$covres #Covariance Matrix
  dim3 <- dim(Phi)[3]
  for (step in 1:dim3){
    Phi_i <- Phi[,,step]
    for (k in 1:K){
      e_j <- rep(0, K); e_j[k] <- 1
      new_col <- Phi_i %*% Sigma %*% e_j / sqrt(Sigma[k,k]) 
      Thita_mat[, k, step] <- new_col 
    }
  }
  return(Thita_mat)
}

.irf.edit <- function(x, impulse = NULL, response = NULL, n.ahead = NULL, irf_type = c("none", "ortho", "generalized"), cumulative = FALSE, y.names = NULL){ #Adapt to irf_type and allow to select Theta matrix if geenralzied option is selected 
    if (is(x, "varest") || is(x, "vec2var")) {
        if (irf_type == "ortho") {
            irf <- vars::Psi(x, nstep = n.ahead)
        }
        else if (irf_type == "generalized") {
            irf <- Theta(x, nstep = n.ahead)
        } else {
            irf <- Phi(x, nstep = n.ahead)
        }
    }
    else if (is(x, "svarest") || is(x, "svecest")) {
        irf <- Phi(x, nstep = n.ahead)
    }
    dimnames(irf) <- list(y.names, y.names, NULL)
    idx <- length(impulse)
    irs <- list()
    for (i in 1:idx) {
        irs[[i]] <- matrix(t(irf[response, impulse[i], 1:(n.ahead + 
            1)]), nrow = n.ahead + 1)
        colnames(irs[[i]]) <- response
        if (cumulative) {
            if (length(response) > 1) 
                irs[[i]] <- apply(irs[[i]], 2, cumsum)
            if (length(response) == 1) {
                tmp <- matrix(cumsum(irs[[i]]))
                colnames(tmp) <- response
                irs[[i]] <- tmp
            }
        }
    }
    names(irs) <- impulse
    result <- irs
    return(result)
}

.boot.edit <- function(x = x, n.ahead = NULL, runs = NULL, 
            irf_type = c("none", "ortho", "generalized"), cumulative = FALSE, impulse = NULL, 
            response = NULL, ci = 0.95, seed = NULL, y.names = NULL){ #Adaptation of .boot function to .irf.edit
  if (!(is.null(seed))) 
        set.seed(abs(as.integer(seed)))
    if (is(x, "varest")) {
        VAR <- eval.parent(x)
    }
    else if (is(x, "svarest")) {
        VAR <- eval.parent(x$var)
    }
    else {
        stop("Bootstrap not implemented for this class.\n")
    }
    p <- VAR$p
    K <- VAR$K
    obs <- VAR$obs
    total <- VAR$totobs
    type <- VAR$type
    B <- Bcoef(VAR)
    BOOT <- vector("list", runs)
    ysampled <- matrix(0, nrow = total, ncol = K)
    colnames(ysampled) <- colnames(VAR$y)
    Zdet <- NULL
    if (ncol(VAR$datamat) > (K * (p + 1))) {
        Zdet <- as.matrix(VAR$datamat[, (K * (p + 1) + 1):ncol(VAR$datamat)])
    }
    resorig <- scale(resid(VAR), scale = FALSE)
    B <- Bcoef(VAR)
    for (i in 1:runs) {
        booted <- sample(c(1:obs), replace = TRUE)
        resid <- resorig[booted, ]
        lasty <- c(t(VAR$y[p:1, ]))
        ysampled[c(1:p), ] <- VAR$y[c(1:p), ]
        for (j in 1:obs) {
            lasty <- lasty[1:(K * p)]
            Z <- c(lasty, Zdet[j, ])
            ysampled[j + p, ] <- B %*% Z + resid[j, ]
            lasty <- c(ysampled[j + p, ], lasty)
        }
        varboot <- update(VAR, y = ysampled)
        if (is(x, "svarest")) {
            varboot <- update(x, x = varboot)
        }
        BOOT[[i]] <- .irf.edit(x = varboot, n.ahead = n.ahead,  irf_type = irf_type, 
            cumulative = cumulative, impulse = impulse, response = response, 
            y.names = y.names) #Just edit here to boot with geenralzied option
    }
    lower <- ci/2
    upper <- 1 - ci/2
    mat.l <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
    mat.u <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
    Lower <- list()
    Upper <- list()
    idx1 <- length(impulse)
    idx2 <- length(response)
    idx3 <- n.ahead + 1
    temp <- rep(NA, runs)
    for (j in 1:idx1) {
        for (m in 1:idx2) {
            for (l in 1:idx3) {
                for (i in 1:runs) {
                  if (idx2 > 1) {
                    temp[i] <- BOOT[[i]][[j]][l, m]
                  }
                  else {
                    temp[i] <- matrix(BOOT[[i]][[j]])[l, m]
                  }
                }
                mat.l[l, m] <- quantile(temp, lower, na.rm = TRUE)
                mat.u[l, m] <- quantile(temp, upper, na.rm = TRUE)
            }
        }
        colnames(mat.l) <- response
        colnames(mat.u) <- response
        Lower[[j]] <- mat.l
        Upper[[j]] <- mat.u
    }
    names(Lower) <- impulse
    names(Upper) <- impulse
    result <- list(Lower = Lower, Upper = Upper)
    return(result)
}

irf.varest.edit <- function (x,impulse = NULL, response = NULL, n.ahead = 10, irf_type = c("none", "ortho", "generalized"), cumulative = FALSE, boot = TRUE, ci = 0.95, runs = 100, seed = NULL, ...) #Ortho argument was replaced by irf_type argument : OIRF, GIRF or no transformation (none). 
{
    if (!is(x, "varest")) {
        stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
    }

    y.names <- colnames(x$y)
    if (is.null(impulse)) {
        impulse <- y.names
    }
    else {
        impulse <- as.vector(as.character(impulse))
        if (any(!(impulse %in% y.names))) {
            stop("\nPlease provide variables names in impulse\nthat are in the set of endogenous variables.\n")
        }
        impulse <- subset(y.names, subset = y.names %in% impulse)
    }
    if (is.null(response)) {
        response <- y.names
    }
    else {
        response <- as.vector(as.character(response))
        if (any(!(response %in% y.names))) {
            stop("\nPlease provide variables names in response\nthat are in the set of endogenous variables.\n")
        }
        response <- subset(y.names, subset = y.names %in% response)
    }
    irs <- .irf.edit(x = x, impulse = impulse, response = response, 
        y.names = y.names, n.ahead = n.ahead, irf_type=irf_type, 
        cumulative = cumulative)
    Lower <- NULL
    Upper <- NULL
    if (boot) {
        ci <- as.numeric(ci)
        if ((ci <= 0) | (ci >= 1)) {
            stop("\nPlease provide a number between 0 and 1 for the confidence interval.\n")
        }
        ci <- 1 - ci
        BOOT <- .boot.edit(x = x, n.ahead = n.ahead, runs = runs, 
            irf_type = irf_type, cumulative = cumulative, impulse = impulse, 
            response = response, ci = ci, seed = seed, y.names = y.names)
        Lower <- BOOT$Lower
        Upper <- BOOT$Upper
    }
    result <- list(irf = irs, Lower = Lower, Upper = Upper, response = response, 
        impulse = impulse,  irf_type = irf_type, cumulative = cumulative, 
        runs = runs, ci = ci, boot = boot, model = class(x))
    class(result) <- "varirf"
    return(result)
}

#Format ACF table
transfo_acf <- function(data){
    df <- as.data.frame(data)
    df$value <- sapply(strsplit(as.character(df$Freq), ":"), function(x) x[2])
    if (any(grepl("NA's\\s*", df$Freq, ignore.case = TRUE))) {
    print("NA detected")
    nrow_exp <- 7
    rows_exp <- c("Min", "Q1", "Median", "Mean", "Q3", "Max", "Missing")
    } else {
    print("NA Undetected")
    nrow_exp <- 6
    rows_exp <- c("Min", "Q1", "Median", "Mean", "Q3", "Max")
    }
    dfexp <- as.data.frame(matrix(NA, nrow=nrow_exp, ncol=length(variables)*2))
    colnames(dfexp) <- c(variables, paste0(variables, "_diff"))
    rownames(dfexp) <- rows_exp
    k <- 0
    for (i in 1:ncol(dfexp)){
    print(i)
    for (j in 1:nrow_exp){
        dfexp[j,i] <- str_trim(df[j + k*nrow_exp, "value"])
    }
    k <- k+1
    }
    return(dfexp)
}

#Plot Tools 

#Create ACF and PACF plots
plot_PACFS <- function(data, type){
    if (!(type %in% c("ACF", "PACF"))){
    stop("Choose ACF or PACF type for schem")
    }
    path_ACF <- paste0("data_prod/var/issue-level/", type, "_plot.png")
    png(file=path_ACF, width = 1800, height = 1200)
    db_plot <- as.data.frame(t(data))
    db_plot <- db_plot[, variables]
    db_plot$stationarity <- ifelse(rownames(db_plot) %in% as.character(stationary_topics), TRUE, FALSE)
    db_plot$topic <- rownames(db_plot)
    db_plot_long <-  db_plot %>% gather(key="groups", value = "value", variables)
    max_y <- max(db_plot_long$value)
    p <- ggplot(data = db_plot_long, aes(x = as.integer(topic), y = value, color=groups, shape = as.factor(stationarity), xmin = 0, xmax = 101, ymin=0, ymax= max_y + 1)) +
        geom_jitter(width = 0.3, size = 5) +  
        scale_shape_manual(values = c("TRUE" = 18, "FALSE" = 16), labels = c("TRUE" = "Stationnaire", "FALSE" = "Mixte"), name = "Stationnarité") +
        scale_color_manual(values = c(
                                "lr" = "blue",
                                "majority" = "orange",
                                "nupes" = "red",
                                "rn" = "purple",
                                "media" = "black", 
                                "majority_supp" = "darkorange", 
                                "lr_supp" = "darkblue", 
                                "nupes_supp" = "darkred", 
                                "rn_supp" = "purple4", 
                                "attentive" = "forestgreen", 
                                "general" = "lightgrey"
                                )) +
        labs(
        title = paste(type, "day where value was < 0.1 for model", args$topic_model),
        x = "Topics",
        y = "Number of days")
    print(p)
    dev.off()
}

#panelvar
panel_lag <- function(x, k) {
  # first column contains time
  # other columns the data
  # k number of lags
  res <-
    rbind(matrix(NA, 1, ncol(x) - 1), as.matrix(x[1:(nrow(x) - 1), -1]), deparse.level = 1)
  colnames(res) <- colnames(x)[-1]
  
  if (k > 1) {
    for (l in 2:k) {
      res <-
        cbind(res, rbind(matrix(NA, l, ncol(x) - 1), as.matrix(x[1:(nrow(x) - l), -1])))
    }
  }
  
  #if (k > 1){
  res[rep(is.na(x[, -1]), k)] <- NA # multiple lags
  #}
  
  # only necessary if single variable with multiple lags
  if(ncol(x) == 2) colnames(res) <- rep(colnames(res)[1], ncol(res))
  
  colnames(res) <- paste0("lag", rep(1:k, each = ncol(x)-1), "_", colnames(res))
  rownames(res) <- NULL
  res
}

panel_forward_lag <- function(x, k) {
  res <-
    rbind(as.matrix(x[(1 + 1):nrow(x),-1]), matrix(NA, 1, ncol(x) - 1), deparse.level = 1)
  colnames(res) <- colnames(x)[-1]

  if (k > 1) {
    for (l in 2:k) {
      res <-
        cbind(res, rbind(as.matrix(x[(1 + l):nrow(x),-1]), matrix(NA, l, ncol(x) - 1)))
    }
  }

  #if (k > 1){
  res[rep(is.na(x[,-1]), k)] <- NA # multiple lags
  #}

  # only necessary if single variable with multiple lags
  if (ncol(x) == 2)
    colnames(res) <- rep(colnames(res)[1], ncol(res))

  colnames(res) <-
    paste0("forwardlag", rep(1:k, each = ncol(x) - 1), "_", colnames(res))
  rownames(res) <- NULL
  res
}

demean <- function(x) {
  x - mean(x, na.rm = TRUE)
}

panel_demean <- function(x, transformation) {
  res <- apply(x[, -(1:2)], 2, demean)
  colnames(res) <- paste("demeaned", colnames(res), sep = "_")
  rownames(res) <- NULL
  res
}

within_transfo <- function(dependent_vars, lags, exog_vars, data, panel_identifier){
  data <- droplevels(data)
  required_vars <- c(dependent_vars)
  if(!(is.null(exog_vars))){
    required_vars <- c(required_vars, exog_vars)
  }
  if (is.numeric(panel_identifier)) {
    Set_Vars <-
      data[, c(colnames(data)[panel_identifier], required_vars)]
  } else {
    Set_Vars <-
      data[, c(panel_identifier, required_vars)]
  }
  
  nof_dependent_vars <- length(dependent_vars)
  if(missing(exog_vars)) {
    nof_exog_vars <- 0
  } else {
    nof_exog_vars <- length(exog_vars)
  }
  categories <- sort(unique(Set_Vars[, 1]))
  periods <- sort(unique(Set_Vars[, 2]))
  nof_categories <- length(categories)
  nof_periods <- length(periods)
  
  name_category <- names(Set_Vars)[1]
  name_period <- names(Set_Vars)[2]
  names(Set_Vars)[1:2] <- c("category", "period")
  
  Set_Vars <- Set_Vars[order(Set_Vars$category, Set_Vars$period,decreasing = FALSE),]
  Set_Vars$category <- factor(Set_Vars$category)
  Set_Vars$period <- factor(Set_Vars$period)
  # Add lags of dependent_vars
  Set_Vars <- cbind(Set_Vars,
                    do.call(
                      rbind,
                      mapply(
                        function(i)
                          panel_lag(Set_Vars[Set_Vars$category == categories[i], c("period", dependent_vars)], lags),
                        1:length(categories),
                        SIMPLIFY = FALSE
                      )
                    )) 
  
  #Consider exog vars 
  if (!(is.null(exog_vars))) {
  Set_Vars <- cbind(Set_Vars,
                    do.call(
                      rbind,
                      mapply(
                        function(i)
                          panel_forward_lag(Set_Vars[Set_Vars$category == categories[i],
                                                     c("period", exog_vars)], lags),
                        1:length(categories),
                        SIMPLIFY = FALSE
                      )
                    ))
  }
  #Demeaning
  Set_Vars <- cbind(Set_Vars,
                    do.call(
                      rbind,
                      mapply(
                        function(i)
                          panel_demean(Set_Vars[Set_Vars$category == categories[i],], demean),
                        1:length(categories),
                        SIMPLIFY = FALSE
                      )
                    )) 
  Set_Vars <- na.exclude(Set_Vars)
  return(Set_Vars)
}

PVARselect <- function(data, dependent_vars, lag.max=10, panel_identifier=c(1,2), exogen=NULL){ 
  lag <- abs(as.integer(lag.max + 1))
  detint <- length(exogen)
  K <- length(dependent_vars)
  nvar <- K + detint
  max_NotUsed <- nvar*(lag) + 2
  data <- as.data.frame(data)
  demeaned_data <- within_transfo(dependent_vars, lag.max, exogen, data, panel_identifier)
  sample <- nrow(demeaned_data)
  demeaned_data <- demeaned_data[, -(1:max_NotUsed)] #Remove not demeaned cols 
  yendog <- as.matrix(demeaned_data[, 1:K])
  max_col_exog <- K + 1 + detint 
  rhs <-  as.matrix(demeaned_data[, (K + 1):max_col_exog])
  if(is.null(exogen)){
    ylagged <- as.matrix(demeaned_data[, (K + 1):(ncol(demeaned_data))])
    rhs <- NULL
  } else {
    max_col_exog <- K + detint
    rhs <- as.matrix(demeaned_data[, (K + 1):max_col_exog])
    ylagged <- as.matrix(demeaned_data[, (max_col_exog + 1):(ncol(demeaned_data) - lag.max*detint)])
  }
  idx <- seq(K, K * lag.max, K)
  criteria <- matrix(NA, nrow = 4, ncol = lag.max)
  rownames(criteria) <- c("AIC(n)", "HQ(n)", "SC(n)", "FPE(n)")
  colnames(criteria) <- paste(seq(1:lag.max))
  for (i in 1:lag.max) {
    ys.lagged <- cbind(ylagged[, c(1:idx[i])], rhs)
    sampletot <- nrow(data)
    nstar <- ncol(ys.lagged)
    resids <- lm.fit(x = ys.lagged, y = yendog)$residuals
    sigma.det <- det(crossprod(resids)/sample)
    criteria[1, i] <- log(sigma.det) + (2/sample) * (i * 
                                                       K^2 + K*detint)
    criteria[2, i] <- log(sigma.det) + (2 * log(log(sample))/sample) * 
      (i * K^2 + K*detint)
    criteria[3, i] <- log(sigma.det) + (log(sample)/sample) * 
      (i * K^2 + K*detint)
    criteria[4, i] <- ((sample + nstar)/(sample - nstar))^K * 
      sigma.det
  }
  order <- apply(criteria, 1, which.min)
  return(list(selection = order, criteria = criteria))
}

panel_portmanteau_test <- function(model, q=2.4, d=NULL,alpha = 0.05, exog=FALSE){
    category_indices <- levels(model$Set_Vars$category)
    num_periods <- length(levels(PVAR_model$Set_Vars$period))
    lags <- model$lags
    endog <- model$dependent_vars
    #Test if we have exogenous variables because if it's the case, the number of observations differ because of forward_lags
    num_col_transfo <- ncol(model$Set_Vars)
    exceptednoexog <- 2 + (lags +1)*length(endog)*2 #Excepted number of columns in model$Set_Vars if there's no exogenous variables (we have 2 (panel_ids) + (no lagged values + lagged values) ((1 + lag)*nb_endog) + demeaned values (all variablex except panel_id*2))
    if (exceptednoexog == num_col_transfo){
      obs <- num_periods - lags
    } else {
      obs <- num_periods - lags*2 #Because forwards lags remove the last observations 
    }
    if (is.null(d)){
      d <- round(obs/12, 0)
    }
    i <- 1
    details_results <- data.frame(matrix(NA, nrow=0, ncol=4))
    colnames(details_results) <- c("Category", "Var", "pvalbeforeadj", "H0")
    for (idx in category_indices){
        start <- (i-1)*obs + 1
        end <- i*obs
        resids <- model$residuals[start:end,]
        result <- data.frame(matrix(NA, nrow=0, ncol=2))
        colnames(result) <- c("Variable", "pvalue")
        for (var in endog){
          demean_var <- paste0('demeaned_', var)
          resid <- resids[, demean_var]
          mean_resid <- mean(resid)
          list_gamma <- c()
          list_theta<- c()
          list_forpi <- c()
          for (j in 1:d){ #Loop to calculate gamma_j and theta_j for each j in 1:d
              sum_j <-0
              sum_j2 <-0
              for (t in (j+1):obs){
                  sum_j <- (resid[t] - mean_resid) * (resid[t-j] - mean_resid) + sum_j
                  sum_j2 <- (resid[t] - mean_resid)^2 * (resid[t-j] - mean_resid)^2 + sum_j2
              }
              gamma_j <- (1/(obs-j) * sum_j)^2
              theta_j <- 1/(obs-j) * sum_j2
              forpi_j <- sqrt(abs(gamma_j/theta_j)) * sqrt(obs) 
  
              list_gamma <- c(list_gamma, gamma_j)
              list_theta <- c(list_theta, theta_j)
              list_forpi <- c(list_forpi, forpi_j)
            }
        #Calculate Lp to define tilde(p)
        list_p <- c()
        for (h in 1:d){
          if(max(list_forpi) > sqrt(q*log(obs))){
              penalty <- 2*h
          } else {
              penalty <- h*log(obs)
          }
          sum_H <- 0 
          for (j in 1:h){
             sum_H <- sum_H + list_gamma[j]/list_theta[j]
          }
          Lh <- obs*sum_H - penalty
          list_p <- c(list_p, Lh) 
        }
        max_val <- max(list_p)
        indices_max <- which(list_p == max_val)
        p <- min(indices_max) 
        #Calculate AQ stat and p-value
        sum_forQ <- 0 
        for (j in 1:p){
            sum_forQ <- sum_forQ + list_gamma[j]/list_theta[j]
        }
        test_stat <- obs*sum_forQ    
        p_value <- 1 - pchisq(test_stat, df=1) #because AQ --> Chi2(1) so we can calculate p-value like this.   
        new_row <- data.frame(
          Variable = var,
          pvalue = p_value 
        )
        result <- rbind(result, new_row)
      }
      #Holm's procedure
      p_values_sorted <- sort(result$pvalue)
      idx_order <- order(result$pvalue)
      var_sorted <- result$Variable[idx_order]
      K <- length(endog)
      rank_H <- 1
      list_padj <- c()
      for (pval in p_values_sorted){
        padj <- pval*K
        if (padj > alpha){
          accepted <- var_sorted[rank_H:length(endog)]
          rejected <- setdiff(var_sorted, accepted)
          H0 <- ifelse(var_sorted %in% accepted, "accepted", "rejected")
          result2 <- data.frame(
            Category = rep(idx, length(endog)),
            Var = var_sorted,
            pvalbeforeadj = p_values_sorted,
            H0 = H0
          )
            break
          } else {
              if (rank_H == length(endog)){
                result2 <- data.frame(
                Category = rep(idx, length(endog)),
                Var = result$Variable,
                pvalbeforeadj = result$pvalue,
                H0 = "rejected"
                )
              }
            }
          K <- K- 1
          rank_H <- rank_H + 1
      }
      details_results <- rbind(details_results, result2)
      i <- i+1
    } 
    colnames(details_results) <-  c("Category", "Var", "pvalbeforeadj", "H0")
    table_test <- details_results %>%
          group_by(Category) %>%
          summarise(nb_accepted = sum(H0 == "accepted"))
    table_test <- as.data.frame(table_test)
    return(list(summary = table_test, details = details_results))
}

jb_multi <- function (x, obs, K, obj.name) {
    P <- chol(crossprod(x)/obs)
    resids.std <- x %*% solve(P)
    b1 <- apply(resids.std, 2, function(x) sum(x^3)/obs)
    b2 <- apply(resids.std, 2, function(x) sum(x^4)/obs)
    s3 <- obs * t(b1) %*% b1/6
    s4 <- obs * t(b2 - rep(3, K)) %*% (b2 - rep(3, K))/24
    STATISTIC <- s3 + s4
    names(STATISTIC) <- "Chi-squared"
    PARAMETER <- 2 * K
    names(PARAMETER) <- "df"
    PVAL <- 1 - pchisq(STATISTIC, df = PARAMETER)
    METHOD <- "JB-Test (multivariate)"
    result1 <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = paste("Residuals of VAR object", 
            obj.name))
    class(result1) <- "htest"
    STATISTIC <- s3
    names(STATISTIC) <- "Chi-squared"
    PARAMETER <- K
    names(PARAMETER) <- "df"
    PVAL <- 1 - pchisq(STATISTIC, df = PARAMETER)
    METHOD <- "Skewness only (multivariate)"
    result2 <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = paste("Residuals of VAR object", 
            obj.name))
    class(result2) <- "htest"
    STATISTIC <- s4
    names(STATISTIC) <- "Chi-squared"
    PARAMETER <- K
    names(PARAMETER) <- "df"
    PVAL <- 1 - pchisq(STATISTIC, df = PARAMETER)
    METHOD <- "Kurtosis only (multivariate)"
    result3 <- list(statistic = STATISTIC, parameter = PARAMETER, 
        p.value = PVAL, method = METHOD, data.name = paste("Residuals of VAR object", 
            obj.name))
    class(result3) <- "htest"
    result <- list(JB = result1, Skewness = result2, Kurtosis = result3)
    return(result)
}

panel_normality_test <-function(model){
    obj.name <- deparse(substitute(x))
    K <- ncol(model$residuals)
    obs <- nrow(model$residuals)
    resid <-  model$residuals
    resids <- scale(resid, scale = FALSE)
    jbm.resids <- jb_multi(resids, obs = obs, K = K, obj.name = obj.name)
    result <- list(resid = resid, jb.mul = jbm.resids)
    return(result)
}