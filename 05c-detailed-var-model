library(dplyr)
library(tidyverse)
library(tidyr)
library(ggplot2)
library(vars)
library(boot)
library(rio)
library(tseries)
library(argparse)
library(stats)
library(stringr)
library(data.table)
library(urca)

parser <- ArgumentParser()

parser$add_argument("topic_model", help="Choose a model type between lda and bertopic")

parser$add_argument("--estimate", action = "store_true",
help = "Run the script who estimate VAR and IRF")

parser$add_argument("--tests", action = "store_true",
                    help = "Activate to do the part where we test stationnarity, stationnarity after differentiation, PACF and ACF informations")

parser$add_argument("--number_irf", help="Choose a int who will represent the number of days in IRF calculation", type="integer", default=21)


args <- parser$parse_args()

if (!(args$topic_model %in% c('bertopic', 'lda'))){
  stop("The model name is incorrect. Choose between lda and bertopic")
}

if (!(args$estimate)){
  if (args$topic_model == 'lda') {
    if(args$media) {
      if (!file.exists("data_prod/var/lda/var_model-MAIN_with_media.Rdata") ||
      !file.exists("data_prod/var/lda/var_irfs-MAIN_with_media.Rdata")) {
        stop("No var and irf files were found. Please run the --estimate option")
      }
    } else {
      if (!file.exists("data_prod/var/lda/var_model-MAIN_without_media.Rdata") ||
      !file.exists("data_prod/var/lda/var_irfs-MAIN_without_media.Rdata")) {
        stop("No var and irf files were found. Please run the --estimate option")
      }
    }
  } else {
     if(args$media) {
      if (!file.exists("data_prod/var/bertopic/var_model-MAIN_with_media.Rdata") ||
      !file.exists("data_prod/var/bertopic/var_irfs-MAIN_with_media.Rdata")) {
        stop("No var and irf files were found. Please run the --estimate option")
      }
    } else {
      if (!file.exists("data_prod/var/bertopic/var_model-MAIN_without_media.Rdata") ||
      !file.exists("data_prod/var/bertopic/var_irfs-MAIN_without_media.Rdata")) {
        stop("No var and irf files were found. Please run the --estimate option")
      }
    }
  }
}

if (args$estimate){
  #Put our main databse generated thanks to script 05a 
  print("Files recuperation and preprocessing")
  if (args$topic_model == 'lda') {
    db <- read_csv("data_prod/var/lda/general_TS_100.csv", show_col_types = FALSE)
    pol_issues <- c(1:100)
  } else {
    db <- read_csv("data_prod/var/bertopic/general_TS.csv", show_col_types = FALSE) 
    pol_issues <- c(0:91)
  }

  db <- db %>%
    filter(topic %in% pol_issues)

  variables <- c('lr', 'majority', 'nupes', 'rn', 'lr_supp', 'majority_supp', 'nupes_supp', 'rn_supp', 'attentive', 'general', 'media')


  if (args$tests){
    count_msg <- 0
    results_list <- list()
    results_list2 <- list()

    concat_statio <- as.data.frame(matrix(NA, nrow = length(variables), ncol=1))
    colnames(concat_statio) <- c("p-value")
    rownames(concat_statio) <- variables

    infos_topic <- data.frame(matrix(NA, nrow=length(pol_issues), ncol=8)) #Seuil ACF, seuil PACF, Stationnarité, Max Modul VAR, VAR select (4), rank 
    colnames(infos_topic) <- c("Topic", "Statio_type", "Max Modul", "AIC", "HQ", "SC", "FPE", "Rank")
  }

  # - logit transform all series
  for (v in variables) {
    # - pulling the series-agenda for that group
    db[[v]] <- as.numeric(db[[v]])
    x <- db[,v]

    if (any(x > 0.998)) { #Treat the case of a proportion value >= 1 (x can be > 1 because of the previous line). We chose 0.999 because rounding of 0.9999 is equal to 1 in db 
      for (i in 1:nrow(x)) {
        if (db[i, v] > 0.998) {
          print(paste("WARNING: due to proportion value equal to 1 or almost equal to 1,  small transformation has been applied for a value in the following group :", v))
          db[i, v] <- 0.998
          }
        }
      }

    x <- db[,v]
    # - adding 1 percentage point to avoid 0s before the logit transformation
    x <- x + 0.001

    # - applying the non-linear transformation
    logit_x <- log(x / (1 - x))
    db[,v] <- logit_x

    if (args$tests) {
      data <- as.ts(db[[v]])
      adf <- adf.test(data)
      p_value <- adf$p.value
      concat_statio[v,1] <- p_value
      if (count_msg == 0) {
         print("Start testing process")
         count_msg <- 1
      }

      no_stationarity_TS_data <- data.frame()
      for (topic_n in pol_issues) { 
        # Augmented Dickey-Fuller (ADF) test for stationarity
        db_topic <- db[db$topic == topic_n, ]
        data <- db_topic[[v]]
        data <- as.ts(data)
        if (sd(data) > 0) {
          adf <- adf.test(data)
          p_value <- adf$p.value
          if (is.nan(p_value)) { #ADF ne gère pas certains cas. On va donc vérifier manuellement par ACF et PACF si les données sont stationnaires
            cat("P-value not calculated for topic:", topic_n, "and variable:", v, "because of data structure and weak variance of the time series. The variance is:", var(data), "A special treatment was done to determine stationnarity using ACF and PACF functions")
            acf_values <- acf(data, plot = FALSE, lag.max = 6)
            pacf_values <- pacf(data, plot = FALSE, lag.max = 6)

            if ((acf_values$acf[3] > 0.1 && acf_values$acf[4] > 0.1 && acf_values$acf[5] > 0.1) || (pacf_values$acf[3] > 0.1 && pacf_values$acf[4] > 0.1 && pacf_values$acf[5] > 0.1)) { #Si l'ACF et la PACF décroient pas assez rapidement, on suppose que la série est pas stationnaire
              results_list <- append(results_list, list(list(topic_n, v, p_value)))
            }
          } else if (p_value > 0.05) {  # Vérifier si la série est non stationnaire
            results_list <- append(results_list, list(list(topic_n, v, p_value)))
          }
        }
      }
    }  
  }

  if (args$tests) {
    cat("Résultats de stationnarité sur les séries concaténées \n")
    results_df <- do.call(rbind, lapply(results_list, function(x) data.frame(t(unlist(x)), stringsAsFactors = FALSE)))
    colnames(results_df) <- c("topic", "variable", "p_value")
    non_full_stationarity_topics <- unique(results_df$topic)

    list_full_top <- list()
    count_full_top <- 0
    for (topic_n in non_full_stationarity_topics){
        db_top <- results_df %>% filter(topic == topic_n)
        if (nrow(db_top) == length(variables)){
            count_full_top <- count_full_top + 1
            list_full_top <- append(list_full_top, topic_n) 
        }
    count_partial_topic <- length(non_full_stationarity_topics) - count_full_top
    }
    stationary_topics <- setdiff(pol_issues, non_full_stationarity_topics)
    cat("Number of topics where time series for each group are stationary: ", length(stationary_topics), "\n")
    cat("The topic numbers that satisfy this property:", stationary_topics, "\n")
    cat("Number of topics where time series for each group are not stationary: ", count_full_top, "\n")
    cat("These topics are : ", paste(list_full_top, collapse= " "), "\n")
    cat("Number of topics where time series are I(0) or I(1) according to group: ", count_partial_topic, "\n")

    count_coint <- 0
    count_ignor_coint <- 0
    list_coint <- list()
    rank_coint <- data.frame(matrix(NA, nrow=length(non_full_stationarity_topics), ncol=2))
    colnames(rank_coint) <- c("topic", "rank")
    ind_top <- 0

    for (topic in non_full_stationarity_topics) {
      ind_top <- ind_top + 1
      db_topic <- db[db$topic == topic, ]
      if (args$topic_model =='lda'){
        sumjo <- summary(ca.jo(db_topic[, variables],type="trace", ecdet = "const", spec="longrun"))
        jo_stat <- sumjo@teststat[length(variables)]
        jo_seuil5 <- sumjo@cval[length(variables), 2]
        if(jo_seuil5<jo_stat){
          count_coint <- count_coint + 1
          list_coint <- append(list_coint, topic)
        }
        rank_coint[ind_top, "topic"] <- topic
        stats <- sumjo@teststat
        seuils <- sumjo@cval[,2]
        rank_val <- 0
        for (i in length(variables):1){
          if(stats[i] < seuils[i]){
            rank_coint[ind_top, "rank"] <- rank_val
            break
          }else{
            rank_val <- rank_val + 1
            if (rank_val==11){
              rank_coint[ind_top, "rank"] <- rank_val
            }
          }
        }
      }
      for (v in variables) {
        data <- db_topic[[v]]
        data <- as.ts(data)
        if (sd(data) > 0) {
          adf <- adf.test(data)
          p_value <- adf$p.value
          if (!is.nan(p_value) && p_value > 0.05) {  # Vérifier si la série est non stationnaire
            data_diff <- diff(data)
            if (sd(data_diff) > 0) {
              adf2 <- adf.test(data_diff)
              p_value2 <- adf2$p.value
              if (is.nan(p_value2)) { #ADF ne gère pas certains cas. On va donc vérifier manuellement par ACF et PACF si les données sont stationnaires
                cat("P-value not calculated for topic:", topic_n, "and variable:", v, "because of data structure and weak variance of the differentiated time series. The variance is:", var(data_diff), "A special treatment was done to determine stationnarity using ACF and PACF functions")
              acf_values <- acf(data, plot = FALSE, lag.max = 6)
              pacf_values <- pacf(data, plot = FALSE, lag.max = 6)

                if ((acf_values$acf[3] > 0.1 && acf_values$acf[4] > 0.1 && acf_values$acf[5] > 0.1) || (pacf_values$acf[3] > 0.1 && pacf_values$acf[4] > 0.1 && pacf_values$acf[5] > 0.1)) { #Si l'ACF et la PACF décroient pas assez rapidement, on suppose que la série est pas stationnaire
                  results_list2 <- append(results_list, list(list(topic_n, v, p_value)))
                }
              }
              else if (p_value2 > 0.05) {
                results_list2 <- append(results_list2, list(list(topic, v, p_value2)))
              }
            }
          }
        }
      }
    }



    if (length(results_list2) == 0) {
      cat("results_list2 est vide, aucun résultat à transformer en dataframe.")
      stationary_topics2 <- non_full_stationarity_topics
    } else {
      cat("results_list2 contient des données.")
      results_df2 <- do.call(rbind, lapply(results_list2, function(x) data.frame(t(unlist(x)), stringsAsFactors = FALSE)))
      colnames(results_df2) <- c("topic", "variable", "p_value")
      non_full_stationarity_topics2 <- unique(results_df2$topic)
      stationary_topics2 <- setdiff(non_full_stationarity_topics, non_full_stationarity_topics2)
    }
    merged_statio <- c(stationary_topics, stationary_topics2)

    cat("Number of topics where time series for each group are stationary or I(1): ", length(merged_statio), "\n")
    cat("The topic numbers that satisfy this property:", merged_statio, "\n")
    if (args$topic_model == 'lda'){
      cat("Number of topics I(1) which have cointegration relations", count_coint, "\n")
      cat("The topic I(1) which satisfy cointegration relations:", paste(list_coint, collapse = " "), " and have following cointegration ranks \n")
      print(summary(rank_coint$rank))
      print(table(rank_coint$rank))
      # Créer une liste vide pour stocker les résultats
      rank_topic_list <- list()

      # Parcourir chaque valeur unique de rank_coint$rank
      for (value in unique(rank_coint$rank)) {
        topics <- rank_coint$topic[rank_coint$rank == value]
        rank_topic_list[[as.character(value)]] <- topics
      }

      cat("Ranks values per topics")
      print(rank_topic_list)
      } else {
        cat("No cointegration tests performed for BERTopic, problem with data structure")
      }

    ACF_data <- data.frame(matrix(NA, nrow = length(variables)*2, ncol = length(pol_issues)))
    PACF_data <- data.frame(matrix(NA, nrow = length(variables)*2, ncol = length(pol_issues)))
    colnames(ACF_data) <- as.character(pol_issues) 
    colnames(PACF_data) <- as.character(pol_issues)
    rownames(ACF_data) <- c(variables, paste0(variables, "_diff"))
    rownames(PACF_data) <- c(variables, paste0(variables, "_diff"))
    counter_const <- 0
    iter_info <-0
    print("Nombre de topic")
    print(length(pol_issues))
    for (topic in pol_issues) {
      iter_info <- iter_info + 1
      infos_topic[iter_info, "Topic"] <- as.character(topic)
      if (topic %in% non_full_stationarity_topics){
        if(topic %in% unlist(list_full_top)){
          infos_topic[iter_info, "Statio_type"] <- "I(1)"
        } else {
          infos_topic[iter_info, "Statio_type"] <- "Mixed"
        }
        if(args$topic_model == 'lda'){
          if (topic %in% list_coint){ 
            row_index = which(rank_coint$topic == topic)
            infos_topic[iter_info, "Rank"] <- rank_coint[row_index, "rank"]
          } else {
            infos_topic[iter_info, "Rank"] <- "No Coint"
          }
        } 
      } else {
        infos_topic[iter_info, "Statio_type"] <- "I(0)"
      }
      topic_str <- as.character(topic)
      db_topic <- db[db$topic == topic, ]
      for (v in variables) {
        data <- db_topic[[v]]
        data <- as.ts(data)
        if (sd(data) == 0) {
          counter_const <- counter_const + 1
        } else{
          data_differ <- diff(data)

          acf_values <- acf(data, lag.max = 30, plot = FALSE)$acf
          pacf_values <- pacf(data, lag.max = 30, plot = FALSE)$acf
          acf_values_diff <- acf(data_differ, lag.max = 30, plot = FALSE)$acf
          pacf_values_diff <- pacf(data_differ, lag.max = 30, plot = FALSE)$acf
        
        # Trouve les premiers lags où ACF et PACF < 0.1
        below_threshold_acf <- which(abs(acf_values) < 0.1)
        below_threshold_pacf <- which(abs(pacf_values) < 0.1)
        below_threshold_acf_diff <- which(abs(acf_values_diff) < 0.1)
        below_threshold_pacf_diff <- which(abs(pacf_values_diff) < 0.1)
        
        # ACF
        if (length(below_threshold_acf) > 0) {
          number_lag_acf <- below_threshold_acf[1]
        } else {
          number_lag_acf <- 31
        }

        if (length(below_threshold_acf_diff) > 0) {
          number_lag_acf_diff <- below_threshold_acf_diff[1]
        } else {
          number_lag_acf_diff <- 31
        }
        
        # PACF
        if (length(below_threshold_pacf) > 0) {
          number_lag_pacf <- below_threshold_pacf[1]
        } else {
          number_lag_pacf <- 31
        }    
        
        if (length(below_threshold_pacf_diff) > 0) {
          number_lag_pacf_diff <- below_threshold_pacf_diff[1]
        } else {
          number_lag_pacf_diff <- 31
        }
        ACF_data[v, topic_str] <- number_lag_acf
        PACF_data[v, topic_str] <- number_lag_pacf
        ACF_data[paste0(v, "_diff"), topic_str] <- number_lag_acf_diff
        PACF_data[paste0(v, "_diff"), topic_str] <- number_lag_pacf_diff
        }
      }
    }

    # Résumé du nombre de séries constantes
    cat("Nombre de séries constantes :", counter_const, "\n")

    transfo_acf <- function(data){
      df <- as.data.frame(data)
      df$value <- sapply(strsplit(as.character(df$Freq), ":"), function(x) x[2])
      if (any(grepl("NA's\\s*", df$Freq, ignore.case = TRUE))) {
        print("NA detected")
        nrow_exp <- 7
        rows_exp <- c("Min", "Q1", "Median", "Mean", "Q3", "Max", "Missing")
      } else {
        print("NA Undetected")
        nrow_exp <- 6
        rows_exp <- c("Min", "Q1", "Median", "Mean", "Q3", "Max")
      }
      dfexp <- as.data.frame(matrix(NA, nrow=nrow_exp, ncol=length(variables)*2))
      colnames(dfexp) <- c(variables, paste0(variables, "_diff"))
      rownames(dfexp) <- rows_exp
      k <- 0
      for (i in 1:ncol(dfexp)){
        print(i)
        for (j in 1:nrow_exp){
          dfexp[j,i] <- str_trim(df[j + k*nrow_exp, "value"])
        }
        k <- k+1
      }
      return(dfexp)
    }

    acf_sum <- summary(t(ACF_data))
    pacf_sum <- summary(t(PACF_data))

    acf_exp <- transfo_acf(acf_sum)
    pacf_exp <- transfo_acf(pacf_sum)

    #Afficher et enregistrer les résultats
    write.csv(ACF_data, file=paste0("data_prod/var/", args$topic_model, "/issue-level/ACF_full.csv"))
    write.csv(PACF_data, file=paste0("data_prod/var/", args$topic_model, "/issue-level/PACF_full.csv"))
    write.csv(acf_exp, file=paste0("data_prod/var/", args$topic_model, "/issue-level/ACF_results.csv"))
    write.csv(pacf_exp, file=paste0("data_prod/var/", args$topic_model, "/issue-level/PACF_results.csv"))

    print(acf_sum)
    print(pacf_sum)

    #Create ACF and PACF plots
    plot_PACFS <- function(data, type){
      if (!(type %in% c("ACF", "PACF"))){
        stop("Choose ACF or PACF type for schem")
      }
      path_ACF <- paste0("data_prod/var/", args$topic_model, "/issue-level/", type, "_plot.png")
      png(file=path_ACF, width = 1800, height = 1200)
      db_plot <- as.data.frame(t(data))
      db_plot <- db_plot[, variables]
      db_plot$stationarity <- ifelse(rownames(db_plot) %in% as.character(stationary_topics), TRUE, FALSE)
      db_plot$topic <- rownames(db_plot)
      db_plot_long <-  db_plot %>% gather(key="groups", value = "value", variables)
      max_y <- max(db_plot_long$value)
      p <- ggplot(data = db_plot_long, aes(x = as.integer(topic), y = value, color=groups, shape = as.factor(stationarity), xmin = 0, xmax = 101, ymin=0, ymax= max_y + 1)) +
          geom_jitter(width = 0.3, size = 5) +  
          scale_shape_manual(values = c("TRUE" = 18, "FALSE" = 16), labels = c("TRUE" = "Stationnaire", "FALSE" = "Mixte"), name = "Stationnarité") +
          scale_color_manual(values = c(
                                  "lr" = "blue",
                                  "majority" = "orange",
                                  "nupes" = "red",
                                  "rn" = "purple",
                                  "media" = "black", 
                                  "majority_supp" = "darkorange", 
                                  "lr_supp" = "darkblue", 
                                  "nupes_supp" = "darkred", 
                                  "rn_supp" = "purple4", 
                                  "attentive" = "forestgreen", 
                                  "general" = "lightgrey"
                                  )) +
         labs(
          title = paste(type, "day where value was < 0.1 for model", args$topic_model),
          x = "Topics",
          y = "Number of days")
      print(p)
      dev.off()
    }
    plot_PACFS(ACF_data, "ACF")
    plot_PACFS(PACF_data, "PACF")


  }

  print("Preprocessing (continued)")
  db$topic <- as.character(db$topic)

  #Model by topic
  lags <- 7
  for (topic in unique(as.character(db$topic))){
    print(paste("Start VAR", topic))
    db_topic <- db %>% filter(as.character(topic) == topic)
    var_model <- VAR(db_topic[, variables], p=lags, type="const")
    #var_irfs_cum <- irf(var_model, n.ahead = 60, cumulative = TRUE)
    #save(var_irfs_cum, file = paste0("var/issue-level/var_irfs_topic_", topic, "_logit-UPD.Rdata"))
    if (args$tests){
      topic <- as.character(topic)
      print(paste("Currently testing topic", topic))
      AIC_and_co <- VARselect(db_topic[, variables], lag.max = 15, season = NULL)
      row_index <- which(as.character(infos_topic$Topic) == topic)
      infos_topic[row_index, "Max Modul"] <- max(roots(var_model))
      infos_topic[row_index, "AIC"] <- AIC_and_co$selection[[1]]
      infos_topic[row_index, "HQ"] <- AIC_and_co$selection[[2]]
      infos_topic[row_index, "SC"] <- AIC_and_co$selection[[3]]
      infos_topic[row_index, "FPE"] <- AIC_and_co$selection[[4]]
    }
  }

  if (args$tests){
    if (args$topic_model == 'lda'){
      path_info <- "data_prod/var/lda/issue-level/infos_topics.csv"
    } else {
      path_info <- "data_prod/var/bertopic/issue-level/infos_topics.csv"
    }
    write.csv(infos_topic, file=path_info, row.names = FALSE)
  }

  stop()


  print("Cumulative IRF preparation")
  var_irfs_cum_merged <- irf(var_model_merged, n.ahead = 60, cumulative = TRUE)

  if (args$topic_model == 'lda') {
    save(var_model_merged, file = "data_prod/var/lda/var_model-MAIN.Rdata")
    save(var_irfs_cum_merged, file = "data_prod/var/lda/var_irfs-MAIN.Rdata")
  } else {
      save(var_model_merged, file = "data_prod/var/bertopic/var_model-MAIN.Rdata")
      save(var_irfs_cum_merged, file = "data_prod/var/bertopic/var_irfs-MAIN.Rdata")
  }
} else {
  if (args$topic_model == 'lda') {
    load("data_prod/var/lda/var_irfs-MAIN.Rdata")
  } else {
    load("data_prod/var/bertopic/var_irfs-MAIN.Rdata")
  }
}


print("Format IRF data in a human-friendly way")

# - load dataset with human-readble labels for the topics
#pa2our <- read.csv("data/pa2our_topics_crosswalk_merged_subissues.csv")

# - a list with variables of interest
variables <- c('lr', 'majority', 'nupes', 'rn', 'lr_supp', 'majority_supp', 'nupes_supp', 'rn_supp', 'attentive', 'general', 'media')

# - initializing an empty dataset where to put all IRF info by topic
irf_data <- NULL

total <- length(pol_issues)
counter <- 0
for (top in pol_issues) {
  # - update counter and report progress
  counter <- counter + 1
  print(paste0("[", counter, "/", total, "]"))
  file_name <- paste0("var/issue-level/var_irfs_topic_", top, "_logit-UPD.Rdata")
  load(file_name) # object name: 'var_irfs_cum'
  
  # - iterating through endogenous covariates and endogenous responses
  covs <- resps <- names(var_irfs_cum$irf)
  for (covariate in covs) {
    for (response in resps) {
      cum_days_n <- nrow(var_irfs_cum$irf[[covariate]])
      new_rows <- data.frame(
        issue_num = top,
        cov = rep(covariate, cum_days_n),
        out = response,
        day = 1:cum_days_n,
        pe = NA, lwr = NA, upr = NA
      )
      
      # - iterating through estimate info (point estimate and lwr and upr CIs)
      for (estimate in c("irf", "Lower", "Upper")) {
        cov_irf_est <- as.data.frame(
          var_irfs_cum[[estimate]][[covariate]]
        )[[response]]
        # - inverting the logit transformation
        if (estimate == "irf") {
          new_rows$pe <- inv.logit(cov_irf_est) - 0.5 
        } else if (estimate == "Lower") {
          new_rows$lwr <- inv.logit(cov_irf_est) - 0.5
        } else {
          new_rows$upr <- inv.logit(cov_irf_est) - 0.5
        }
      }
      #print(paste0(covariate, " -> ", response))
      # - appending new rows to the main dataset with all IRF info
      irf_data <- rbind(irf_data, new_rows)
    }
  }
}

# - a version only keeping both parties in Congress, supporters of both parties,
#     and attentive publics
irf_plot <- irf_data %>%
  filter(cov %in% variables,
         out %in% variables)

# - removing rows where covariate and response are the same variable, and also
#     removoing info about how public agendas influence public agendas, and how
#     political agendas influence political agendas
agenda_type <- data.frame(
  var = variables,
  type = c("pol", "pol", "pol", "pol", "pub", "pub", "pub", "pub", "pub", "pub", "media")
)
cov_agenda_type <- agenda_type %>%
  rename(cov = var, cov_agenda_type = type)
out_agenda_type <- agenda_type %>%
  rename(out = var, out_agenda_type = type)

cov_agenda_type$cov <- as.character(cov_agenda_type$cov)
out_agenda_type$out <- as.character(out_agenda_type$out)
irf_plot$cov <- as.character(irf_plot$cov)
irf_plot$out <- as.character(irf_plot$out)

irf_plot <- left_join(irf_plot, cov_agenda_type)
irf_plot <- left_join(irf_plot, out_agenda_type)

irf_plot <- irf_plot %>%
  filter(cov_agenda_type != out_agenda_type)

# - merging to the dataset a human readable name for the topics
pa2our_tomerge <- pa2our %>%
  dplyr::select("our_", "our_topic_label") %>%
  rename(issue_num = our_, label = our_topic_label)

pa2our_tomerge$issue_num <- as.character(pa2our_tomerge$issue_num)
irf_plot$issue_num <- as.character(irf_plot$issue_num)

irf_plot <- left_join(irf_plot, pa2our_tomerge)

# - reorder the levels of the outcome and covariate factor variables
irf_plot$cov <- recode(irf_plot$cov,
                          `lr` = "LR in Congress",
                          `majority` = "Majority in Congress",
                          `nupes` = "NUPES in Congress",
                          `rn` = "RN in Congress",
                          `lr_supp` = "LR Supporters",
                          `majority_supp` = "Majority Supporters",
                          `nupes_supp` = "NUPES Supporters",
                          `rn_supp` = "RN Supporters",
                          `attentive` = "Attentive Public",
                          `general` = "General Public",
                          `media` = "Media")

irf_plot$out <- recode(irf_plot$out,
                          `lr` = "LR in Congress",
                          `majority` = "Majority in Congress",
                          `nupes` = "NUPES in Congress",
                          `rn` = "RN in Congress",
                          `lr_supp` = "LR Supporters",
                          `majority_supp` = "Majority Supporters",
                          `nupes_supp` = "NUPES Supporters",
                          `rn_supp` = "RN Supporters",
                          `attentive` = "Attentive Public",
                          `general` = "General Public",
                          `media` = "Media")

irf_plot$out <- factor(irf_plot$out,
                                levels = c("LR in Congress",
                                          "Majority in Congress",
                                          "NUPES in Congress",
                                          "RN in Congress",
                                          "LR Supporters",
                                          "Majority Supporters",
                                          "NUPES Supporters",
                                          "RN Supporters",
                                          "Attentive Public",
                                          "General Public",
                                          "Media"))

irf_plot$cov <- factor(irf_plot$cov,
                                levels = c("LR in Congress",
                                          "Majority in Congress",
                                          "NUPES in Congress",
                                          "RN in Congress",
                                          "LR Supporters",
                                          "Majority Supporters",
                                          "NUPES Supporters",
                                          "RN Supporters",
                                          "Attentive Public",
                                          "General Public",
                                          "Media"))

# - better labels for the data type
all_irf_data_wide$data_type <- recode(
  all_irf_data_wide$data_type,
  `one_time_shock` =  "Effect of a one time 10 percentage point attention increase at day 0",
  `structural` = "Effect of a structural 10 percentage point attention increase at day 0")


if (args$topic_model == 'lda') {
  if (args$media){
    write.csv(all_irf_data_wide,
            "data_prod/var/lda/onetime-structural-shock-irfs-results-media.csv",
            row.names = FALSE)
    final_input <- import("data_prod/var/lda/onetime-structural-shock-irfs-results-media.csv")
  } else {
    write.csv(all_irf_data_wide,
          "data_prod/var/lda/onetime-structural-shock-irfs-results.csv",
          row.names = FALSE)
  final_input <- import("data_prod/var/lda/onetime-structural-shock-irfs-results.csv")
  }
} else {
  if (args$media){
    write.csv(all_irf_data_wide,
          "data_prod/var/bertopic/onetime-structural-shock-irfs-results-media.csv",
          row.names = FALSE)
    final_input <- import("data_prod/var/bertopic/onetime-structural-shock-irfs-results-media.csv")

  } else {
    write.csv(all_irf_data_wide,
          "data_prod/var/bertopic/onetime-structural-shock-irfs-results.csv",
          row.names = FALSE)
    final_input <- import("data_prod/var/bertopic/onetime-structural-shock-irfs-results.csv")
  }
   
}
print("Create plot data")


# DATA WRANLGING
#===============================================================================
# - exploring only args$number_irf-day effects, and removing the Media from the analysis.
plot_db <- final_input %>%
  filter(day == args$number_irf)

plot_db$cov <- recode(plot_db$cov,
                    `LR in Congress` = "LR in\nCongress",
                    `Majority in Congress` = "Majority in\nCongress",
                    `NUPES in Congress` = "NUPES in\nCongress",
                    `RN in Congress` = "RN in\nCongress",
                    `LR Supporters` = "LR\nSupporters",
                    `Majority Supporters` = "Majority\nSupporters",
                    `NUPES Supporters` = "NUPES\nSupporters",
                    `RN Supporters` = "RN\nSupporters",
                    `Attentive Public` = "Attentive\nPublic",
                    `General Public` = "General\nPublic")

plot_db$out <- recode(plot_db$out,
                    `LR in Congress` = "LR in\nCongress",
                    `Majority in Congress` = "Majority in\nCongress",
                    `NUPES in Congress` = "NUPES in\nCongress",
                    `RN in Congress` = "RN in\nCongress",
                    `LR Supporters` = "LR\nSupporters",
                    `Majority Supporters` = "Majority\nSupporters",
                    `NUPES Supporters` = "NUPES\nSupporters",
                    `RN Supporters` = "RN\nSupporters",
                    `Attentive Public` = "Attentive\nPublic",
                    `General Public` = "General\nPublic")

# - reordering the covariate and outcome categories

irf_plot$cov <- factor(irf_plot$cov,
                      levels = rev(c("LR in\nCongress",
                                      "Majority in\nCongress",
                                      "NUPES in\nCongress",
                                      "RN in\nCongress",
                                      "LR\nSupporters",
                                      "Majority\nSupporters",
                                      "NUPES\nSupporters",
                                      "RN\nSupporters",
                                      "Attentive\nPublic",
                                      "General\nPublic",
                                      "Media")))

irf_plot$out <- factor(irf_plot$out,
                    levels = c("LR in\nCongress",
                                "Majority in\nCongress",
                                "NUPES in\nCongress",
                                "RN in\nCongress",
                                "LR\nSupporters",
                                "Majority\nSupporters",
                                "NUPES\nSupporters",
                                "RN\nSupporters",
                                "Attentive\nPublic",
                                "General\nPublic", 
                                "Media"))

plot_db <- irf_plot %>%
  # - only keeping IRF that don't cross 0
  filter(day == args$number_irf) %>%
  arrange(out, cov, pe) %>%
  mutate(label = factor(label, levels = unique(label))) %>%
  filter(sign(lwr) == sign(upr))
  

# - sort by the issues in which Democratic supporters are more likely to lead 
#   the attention of Democrats in Congress

if(args$topic_model=="lda"){
  path_img <- "data_prod/figures/lda/figure4.png"
} else {
  path_img <- "data_prod/figures/bertopic/figure4.png"
}
# PLOT -- FIGURE 4
#===============================================================================
png(path_img, width = 1600, height = 1400)
ggplot(plot_db %>% 
         mutate(pe = (pe * 100)/10, lwr = (lwr * 100)/10, upr = (upr * 100)/10),
       aes(x = label, y = pe, ymin = lwr, ymax = upr)) +
  geom_pointrange(aes(col = cov), alpha = 0.4, size = 1.05) +
  geom_hline(yintercept = 0, color = "red") +
  facet_wrap(~out, nrow = 1) +
  coord_flip() +
  xlab("") +
  ylab("\nThe effect of a 10 percentage point increase in attention by the covariate group, measured in percentage point change") +
  scale_color_manual("", values = c("blue", "yellow",
                                    "red", "brown", 
                                    "blue4", "yellow4",
                                    "red4", "brown4", 
                                    "gray50", "orange2", "purple")) +
  theme(
    panel.background = element_blank(),
    panel.grid.major = element_line(colour = "gray90", linetype = "solid"),
    axis.text.x = element_text(size = 16),
    axis.text.y = element_text(size = 16),
    strip.text = element_text(size = 16),
    panel.border = element_rect(colour = "black", fill = FALSE),
    strip.background = element_rect(colour = "black"),
    axis.title = element_text(size = 14),
    legend.text = element_text(size = 14, margin = margin(t = 20), vjust = 5)
  )
dev.off()
